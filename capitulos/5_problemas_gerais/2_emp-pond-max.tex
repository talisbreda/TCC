\subsection{Emparelhamento ponderado máximo}

Enquanto o problema de cardinalidade máxima busca o maior número de arestas, o problema do \textbf{Emparelhamento de Peso Máximo} (Maximum Weight Matching) introduz uma função de peso $w: E \to \mathbb{R}$ nas arestas, e o objetivo torna-se encontrar um emparelhamento $M$ que maximize $\sum_{e \in M} w(e)$. Este problema é a generalização natural do Problema da Atribuição para grafos não-bipartidos, descrito em \ref{sec:assignment_problem}.

A complexidade deste problema em grafos gerais decorre, assim como no problema de emparelhamento de cardinalidade máxima descrito em \ref{sec:emp_card_max_geral}, da presença de ciclos ímpares. Se tentarmos modelar o problema usando Programação Linear (PL) apenas com restrições de grau ($\sum x_e \le 1$), a solução ótima do sistema relaxado pode ser fracionária (ex: $x_e = 0.5$ para as três arestas de um triângulo), o que não corresponde a um emparelhamento válido.

\subsubsection{Formulação poliédrica e Restrições de Blossom}

Conforme detalhado por \citeonline{schrijver}, para descrever o \textbf{Poliedro do Emparelhamento} (Matching Polytope) em grafos gerais, Edmonds (1965) provou que é necessário adicionar uma família exponencial de restrições conhecidas como \textbf{Desigualdades de Blossom} (ou restrições de subconjuntos ímpares):

\begin{equation}
    \sum_{e \in E(U)} x_e \le \frac{|U| - 1}{2}, \quad \forall U \subseteq V, |U| \text{ ímpar}, |U| \ge 3
\end{equation}

Onde $E(U)$ é o conjunto de arestas com ambas as extremidades em $U$. Essas inequações garantem que, em qualquer subconjunto ímpar de vértices, o número de arestas selecionadas não exceda a capacidade máxima inteira possível.

\subsubsection{A abordagem Primal-Dual}

Diferente do caso de cardinalidade, onde buscamos apenas caminhos aumentantes, o algoritmo para o caso ponderado é um método \textbf{Primal-Dual}. Ele é uma generalização do Método Húngaro, mas adaptado para lidar com as blossoms.

Segundo \citeonline{lawler}, o algoritmo mantém variáveis duais não apenas para os vértices ($y_v$), mas também para cada subconjunto ímpar de vértices ($z_B$) que forma uma blossom contraída. A condição de otimalidade baseia-se na folga complementar. Uma aresta $(u, v)$ é considerada "admissível" ou "justa" (\textit{tight}) se a soma dos duais correspondentes iguala o peso da aresta. Simplificadamente:

\begin{equation}
    y_u + y_v + \sum_{B : (u,v) \in B} z_B = w_{uv}
\end{equation}

O algoritmo opera iterativamente em dois estágios, descritos por \citeonline{jungnickel} e \citeonline{schrijver}:

\begin{enumerate}
    \item \textbf{Estágio Primal (Busca):} Restringindo-se apenas às arestas admissíveis (onde a equação acima é satisfeita), o algoritmo busca um caminho aumentante usando a técnica de contração de blossoms de Edmonds. Se encontrado, o emparelhamento é aumentado.
    \item \textbf{Estágio Dual (Ajuste de Preços):} Se a busca falha em encontrar um caminho aumentante no grafo de arestas admissíveis, o algoritmo não termina (ao contrário do caso de cardinalidade). Em vez disso, ele realiza uma atualização das variáveis duais $y$ e $z$.
    \begin{itemize}
        \item O algoritmo calcula um valor $\delta$ (delta), que é a menor "folga" entre as arestas que conectam a árvore de busca atual a vértices externos.
        \item Os duais dos vértices na árvore são ajustados por $\pm \delta$ e os duais das blossoms ($z_B$) também são ajustados.
        \item Esse ajuste tem o efeito de "destravar" novas arestas (tornando-as admissíveis) ou permitir a expansão/contração de blossoms, possibilitando que a busca prossiga.
    \end{itemize}
\end{enumerate}

\subsubsection{O algoritmo de Edmonds Ponderado}

O procedimento resultante é frequentemente chamado de \textbf{Algoritmo de Blossom Ponderado} ou simplesmente Algoritmo de Edmonds para Emparelhamento Ponderado.

A implementação original de Edmonds era polinomial, $O(V^4)$. \citeonline{lawler} apresentou uma implementação $O(V^3)$, que por muito tempo foi o padrão em livros didáticos.

A variante $O(V^3)$ descrita por Lawler (1976) para o emparelhamento ponderado utiliza uma abordagem primal-dual rigorosa. O algoritmo mantém um conjunto de arestas admissíveis (custo reduzido nulo) baseadas em variáveis duais de vértices ($y_i$) e de subconjuntos ímpares ($z_B$). A cada iteração onde a busca por caminhos aumentantes falha, o algoritmo calcula um escalar crítico $\delta$ baseado nas folgas das arestas incidentes à árvore alternante atual (conjunto $S$). A atualização dual subsequente ($y_i \leftarrow y_i \pm \delta$, $z_B \leftarrow z_B \pm 2\delta$) garante o surgimento de novas arestas admissíveis ou a expansão de *blossoms* com dual nulo, mantendo a complexidade cúbica através do gerenciamento eficiente dos valores de folga mínima (*slack*) para vértices fora da árvore.

Lawler também destaca que a manipulação das variáveis duais das blossoms ($z_B$) é o que permite ao algoritmo "pagar" o custo de usar arestas dentro de estruturas cíclicas ímpares. Quando uma blossom é formada durante a busca, ela recebe um valor dual $z_B > 0$; quando ela precisa ser desfeita (expandida) para encontrar um caminho, seu valor dual retorna a zero.

\subsubsection{Otimizações}

Desenvolvimentos posteriores por \citeonline{galil_micali_gabow} e \citeonline{gabow1990} melhoraram a estrutura de dados para gerenciar a prioridade das atualizações duais e a contração de blossoms, atingindo complexidades próximas a $O(E V \log V)$ ou $O(E \sqrt{V \alpha(E, V)})$ em implementações de escalonamento \cite{schrijver}.

Apesar de ser polinomial (classe P), a implementação de emparelhamento ponderado em grafos gerais é considerada uma das rotinas mais complexas da otimização combinatória clássica, sendo significativamente mais difícil de implementar corretamente do que algoritmos para grafos bipartidos ou fluxo máximo.


% #### D. Algoritmos de Crescimento de Caminho (Path Growing)
% Proposto especificamente para emparelhamento ponderado em grafos gerais para superar a complexidade do algoritmo de Blossom.
% * **Funcionamento:** Cresce caminhos simples escolhendo sempre a aresta mais pesada disponível localmente. Quando o caminho não pode crescer mais, processa o caminho (selecionando arestas alternadas usando Programação Dinâmica linear) para maximizar o peso local.
% * **Complexidade:** $O(E)$.
% * **Garantia:** Aproximação de **1/2**.
% * **Referência:** **Drake, D. E., & Hougardy, S. (2003).** *A simple approximation algorithm for the weighted matching problem*. Information Processing Letters.

\subsubsection{Heurísticas}

Aqui também podemos utilizar a mesma heurística que usamos para a versão do problema para grafos bipartidos: a Heurística Gulosa Ordenada, descrita na seção \ref{p:gulosa_ordenada}. Mas além dessas, temos:

\paragraph{Algoritmo de Crescimento de Caminho (Path Growing)}

Similar à heurística descrita na seção \ref{p:h_path_growing_card}, esta também faz uso de Path Growing para encontrar um emparelhamento. A vantagem desta é que não é necessário ordenação, tornando possível a execução em tempo linear ($O(E)$). Foi descrito por \citeonline{drake}:

\begin{enumerate}
    \item O algoritmo constrói caminhos simples disjuntos no grafo.
    \item Comece em um vértice livre $v$ qualquer. Estenda o caminho escolhendo a aresta de maior peso conectada a $v$ que leve a um vértice ainda não visitado neste caminho.
    \item Repita até que o caminho não possa crescer mais.
    \item Dado um caminho $P = (e_1, e_2, e_3, \dots, e_k)$, temos dois emparelhamentos possíveis formados por arestas alternadas:
    \item 
        \begin{itemize}
            \item $M_1 = \{e_1, e_3, e_5, \dots\}$ (Arestas ímpares)
            \item $M_2 = \{e_2, e_4, e_6, \dots\}$ (Arestas pares)
        \end{itemize}
    \item Compare o peso total de $M_1$ e $M_2$. Adicione o conjunto mais pesado à solução final e remova os vértices do grafo.
\end{enumerate}

A diferença para a versão de emparelhamento de cardinalidade máxima é o passo 5, onde os pesos são somados para escolher o melhor conjunto. Garante emparelhamento de pelo menos $1/2$ da cardinalidade máxima \cite{drake}.

\begin{table}[ht]
    \centering
    \caption{Algoritmos para problema de emparelhamento ponderado máximo em grafos gerais}
    \label{tab:emp_pond_max_gerais}
    \renewcommand{\arraystretch}{1.2} % Adds a little vertical padding
    
    % Structure: l = left align, c = center, X = auto-wrap paragraph
    \begin{tabularx}{\textwidth}{@{} l l l X @{}}
        \toprule
        \textbf{Algoritmo} & \textbf{Complexidade de tempo} & \textbf{Tipo} & \textbf{Descrição} \\
        \midrule
        
        Edmonds & $O(V^3)$ & Exato & 
        Método primal-dual que gerencia variáveis duais para vértices e blossoms, ajustando preços para encontrar caminhos no grafo de igualdade. \\
        \addlinespace 

        Edmonds otimizado & $O(EV \log V)$ & Exato & 
        Melhoria do Edmonds original através de uma série de otimizações \\
        \addlinespace 

        Gulosa ordenada & $O(E \log E)$ & Heurística & 
        Ordena as arestas por peso decrescente e seleciona iterativamente as disponíveis. \\
        \addlinespace

        Crescimento de caminho & $O(E)$ & Heurística & 
        Heurística que estende caminhos pela aresta mais pesada local e seleciona o subconjunto de arestas (par ou ímpar) de maior soma total. \\
        
        \bottomrule
    \end{tabularx}
\end{table}