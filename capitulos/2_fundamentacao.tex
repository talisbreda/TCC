%!TeX root = ../main.tex
\section{Fundamentação teórica}

% ==================================================================================================================================
% 2.1. Definições sobre grafos
% ==================================================================================================================================
\subsection{Definições sobre grafos}


Um \textbf{grafo} $G$ é uma uma estrutura definida por um par $G=(V,E)$, consistindo de um conjunto finito $V$ de elementos 
chamados \textbf{vértices} (ou \textbf{nós} ou \textbf{pontos}) e um conjunto (ou família) $E$ de pares não ordenados de vértices, 
chamados de \textbf{arestas} \cite{jungnickel}. O conjunto V é o conjunto de vértices de $G (VG)$ e $E$ é a família de arestas de 
$G (EG)$.

No contexto deste projeto, assumimos que as arestas $e={u,v}$ são pares não ordenados de vértices distintos. Se uma aresta $e$ 
conecta os vértices $a$ e $b$, diz-se que $a$ e $b$ são \textbf{adjacentes} ou \textbf{vizinhos}, e que a aresta $e$ é 
\textbf{incidente} a $a$ e $b$ \cite{schrijver}.

O conceito de grafo é amplamente utilizado como uma representação abstrata concisa para estruturas complexas e para 
codificar relações binárias entre um conjunto de objetos.

% ---------------------------------------------------------------------------------------------------------------------------------
% 2.1.1. Grafo direcionado
% ---------------------------------------------------------------------------------------------------------------------------------
\subsubsection{Grafo direcionado}

Se as relações entre os vértices forem assimétricas, utilizamos um \textbf{grafo direcionado} ou \textbf{dígrafo}, $D=(V,A)$. 
Neste caso, $A$ é uma família de pares ordenados de vértices, chamados \textbf{arcos} (ou arestas direcionadas). 
Para um arco $e=(u,v)$, $u$ é chamado o vértice inicial ou \textbf{cauda} (tail), e $v$ é o vértice final ou \textbf{cabeça} (head)
\cite{manber}

% ---------------------------------------------------------------------------------------------------------------------------------
% 2.1.2. Grafo ponderado
% ---------------------------------------------------------------------------------------------------------------------------------
\subsubsection{Grafo ponderado}

Um grafo $G=(V,E)$ é chamado \textbf{grafo ponderado} (ou com pesos) se uma \textbf{função de peso} (ou função de custo, 
ou função de comprimento) $w:E\rightarrow R$ está associada às arestas. Formalmente: $G=(V,E,w)$, onde $w:E\rightarrow R$. 
Geralmente, o peso $w(e)$ de uma aresta $e$ é um valor real não negativo que representa o custo, comprimento ou capacidade 
associada àquela aresta \cite{rosen}.

Grafos ponderados podem ser representados por matrizes de adjacência de valor real $A$, onde a entrada $A_{ij}$ 
é o peso $w_{ij}$ da aresta \cite{path_following_algo}

% ---------------------------------------------------------------------------------------------------------------------------------
% 2.1.3. Grafo bipartido
% ---------------------------------------------------------------------------------------------------------------------------------
\subsubsection{Grafo bipartido}

Um grafo bipartido é um grafo não direcionado que pode ser facilmente colorido com apenas duas cores \cite{manber}

Formalmente, um grafo $G=(V,E)$ é chamado \textbf{grafo bipartido} se o conjunto de vértices $V$ puder ser
particionado em dois subconjuntos disjuntos $V_1$ e $V_2$, chamados calsses de cor, tais que:

\begin{equation}
    V = V_1 \cup V_2 \quad {e} \quad V_1 \cap V_2 = \emptyset
\end{equation}

e todas as arestas $e \in E$ conectam um vértice em $V_1$ a um vértice em $V_2$. Ou seja, não existem arestas que conectem
vértices dentro do mesmo subconjunto \cite{dasgupta}.

Observações:
\begin{itemize}
    \item Um grafo é bipartido se e somente se não contém ciclos de comprimento ímpar \cite{schrijver}
    \item O grafo bipartido completo $K_{m,n}$ possui $m$ vértices em $V_1$ e $n$ vértices em $V_2$, 
    e contém todas as arestas possíveis entre $V_1$ e $V_2$ \cite{jungnickel}
\end{itemize}


% TODO: teorema da integralidade
% TODO: Mendelsohn-Dulmage

\subsection{Redes de fluxo em grafos}

A teoria dos fluxos em redes é um ramo fundamental da otimização combinatória que modela problemas de transporte de recursos através de um sistema conectado. Esta seção define os conceitos preliminares e apresenta os teoremas centrais que sustentam os algoritmos utilizados neste trabalho.

\subsubsection{Definições básicas}

Uma rede de fluxo é definida por um grafo direcionado $G = (V, E)$, onde $V$ é o conjunto de vértices e $E$ é o conjunto de arestas. Distinguem-se dois vértices especiais: a \textbf{fonte} $s\in V$. que produz o fluxo, e o \textbf{sorvedouro} $t\in V$, que o consome. Para cada aresta $(u, v) \in E$, associa-se uma capacidade não-negativa $c(u,v) \geq o$, que limita a quantidade de fluxo que pode atravessar aquela aresta. Um \textbf{fluxo} em $G$ é uma função $f \space : \space E \rightarrow \mathbb{R}^+$ que satisfaz as seguintes propriedades \cite{cormen}:

\begin{itemize}
    \item \textbf{Restrição de capacidade:} O fluxo em uma aresta não pode exceder a sua capacidade.
    \begin{equation}
        0 \leq f(u,v) \leq c(u,v), \qquad \forall(u,v) \in E
    \end{equation}
    \item \textbf{Conservação de fluxo:} para todo vértice $v \in V - \{s,t\}$, a quantidade total de fluxo que entra deve ser igual à que sai
    \begin{equation}
        \sum_{v \in V}f(v,u) = \sum_{v \in V}f(u,v)
    \end{equation}
\end{itemize}

\subsubsection{O problema do fluxo máximo}

O \textbf{problema do fluxo máximo} consiste em encontrar um fluxo $f$ tal que $|f|$ seja o maior possível. Para entender a limitação desse fluxo, precisamos entender os conceitos de corte, redes residuais e caminhos aumentantes.

\paragraph{Corte}

Um \textbf{corte} $(S,T)$ é uma partição do conjunto de vértices $V$ em dois subconjuntos disjuntos $S$ e $T$, tal que $s\in S$ e $t\in T$. A \textbf{capacidade do corte}, denotada por $c(S,T)$, é a soma das capacidades das arestas que partem de $S$ para $T$ \cite{cormen}:

\begin{equation}
    c(S,T) = \sum_{u\in S,v\in T}c(u,v)
\end{equation}

O \textbf{corte mínimo} de uma rede $N$ é um corte cuja capacidade é a menor entre todos os cortes possíveis nessa rede \cite{cormen}. Isso nos leva ao \textbf{teorema do fluxo máximo e corte mínimo (Max-flow Min-cut)}

\begin{quotation}
    \textit{O valor máximo do fluxo de uma rede $N$ é igual à capacidade do corte mínimo em $N$ \cite{jungnickel}}
\end{quotation}

Este teorema é fundamental para a compreensão e corretudo dos algoritmos de caminhhos aumentantes.

\paragraph{Redes residuais}

A maioria dos algoritmos de resolução de problemas de fluxo máximo se baseia no conceito de redes residuais. Uma \textbf{rede residual} $G_f$ consiste em arestas com capacidades que representam como podemos alterar o fluxo das arestas em $G$. A capacidade das arestas da rede residual $G_f$ corresponde à diferença entre a capacidade da aresta original de $G$ e o fluxo $f$ que está passando pela aresta \cite{cormen}. Ou seja:

\begin{equation}
    c_f(u,v) = c(u,v) - f(u,v)
\end{equation}

Quando a aresta $(u,v)$ possui fluxo igual à sua capacidade, $c_f(u,v) = 0$ e a aresta não é incluída no grafo residual $G_f$

\paragraph{Caminhos aumentantes}

Dado um grafo $G=(V,E)$ e um fluxo $f$, um \textbf{caminho aumentante} é um caminho de $s$ para $t$ na rede residual $G_f$. Por definição, podemos aumentar o fluxo em uma aresta $(u,v)$ de um caminho aumentante em até $c_f(u,v)$ sem violar a capacidade da aresta original em $G$ \cite{cormen}.

O método de Ford-Fulkerson, que é base dos principais algoritmos de resolução do problema do fluxo máximo, iterativamente encontra um caminho aumentante, calcula sua capacidade residual e adiciona esse fluxo à solução atual até que não existam mais caminhos aumentantes \cite{ahuja}.

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetAlgoLined

    \Fn{FORD-FULKERSON($G, s, t$)}{
        \ForEach{edge $(u, v) \in G.E$}{
            $(u, v).f \leftarrow 0$\;
        }
        
        \While{there exists a path $p$ from $s$ to $t$ in the residual network $G_f$}{
            $c_f(p) \leftarrow \min \{ c_f(u, v) : (u, v) \text{ is in } p \}$\;
            
            \ForEach{edge $(u, v) \in p$}{
                \eIf{$(u, v) \in E$}{
                    $(u, v).f \leftarrow (u, v).f + c_f(p)$\;
                }{
                    $(v, u).f \leftarrow (v, u).f - c_f(p)$\; 
                }
            }
        }
    }
    
    \caption{Ford-Fulkerson Algorithm}
    \label{alg:ford_fulkerson}
\end{algorithm}

\paragraph{Algoritmo de Edmonds-Karp}
\label{p:edmonds-karp}

O algoritmo de \textbf{Edmonds-Karp} é uma especialização do método de Ford-Fulkerson que utiliza uma busca em largura (BFS) para encontrar sempre o camino aumentante mais curto em número de arestas. Tem complexidade de tempo $O(VE^2)$:

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetAlgoLined

    % Variáveis globais explicadas no início (opcional, mas ajuda na clareza)
    \textbf{Global:} $res$ (matriz de capacidade residual), $mf, f, s, t$, $p$ (vetor de pais da BFS)\;
    \bigskip

    % Procedimento Recursivo AUGMENT
    \Fn{Augment($v, \text{minEdge}$)}{
        \eIf{$v = s$}{
            $f \leftarrow \text{minEdge}$\;
            \KwRet\;
        }{
            \If{$p[v] \neq -1$}{
                Augment($p[v], \min(\text{minEdge}, res_{p[v], v})$)\;
                $res_{p[v], v} \leftarrow res_{p[v], v} - f$\;
                $res_{v, p[v]} \leftarrow res_{v, p[v]} + f$\;
            }
        }
    }

    \bigskip

    % Procedimento Principal (Main)
    \Fn{EdmondsKarp($s, t$)}{
        $mf \leftarrow 0$\;
        
        \While{\KwTrue}{
            $f \leftarrow 0$\;
            
            % Setup da BFS
            $dist \leftarrow \infty; \quad dist[s] \leftarrow 0$\;
            $Q \leftarrow \{s\}; \quad p \leftarrow \text{nil}$ (init vector with -1)\;

            % BFS Loop
            \While{$Q \neq \emptyset$}{
                $u \leftarrow Q.\text{front}()$; $Q.\text{pop}()$\;
                
                \If{$u = t$}{
                    \KwBreak (stop BFS)\;
                }

                \For{each $v \in V$}{
                    \If{$res_{u, v} > 0$ \KwAnd $dist[v] = \infty$}{
                        $dist[v] \leftarrow dist[u] + 1$\;
                        $Q.\text{push}(v)$\;
                        $p[v] \leftarrow u$\;
                    }
                }
            }

            Augment($t, \infty$); \textbf{[comment: find min edge weight $f$ in path]}\;
            
            \If{$f = 0$}{
                \KwBreak (terminate)\;
            }
            $mf \leftarrow mf + f$\;
        }
        
        \KwRet $mf$\;
    }
    
    \caption{Algoritmo de Edmonds-Karp \cite{halim}}
    \label{alg:edmonds_karp}
\end{algorithm}

\paragraph{Algoritmo de Dinic}

TODO

\subsubsection{Fluxo de custo mínimo}

Uma outra variação dos problemas em redes de fluxo em grafos é o problema do fluxo de custo mínimo. Essa variação considera, além das capacidades disponíveis, uma dimensão econômica. Seja $G=(V, E)$ uma rede direcionada one cada aresta $(u,v)$ possui uma capacidade $c(u,v)$ e um custo unitário $w(u,v)$. O objetivo é transmitir uma quantidade de fluxo pré-determinada $v$ da fonte $s$ ao sorvedouro $t$ com o menor custo total possível.

% ==================================================================================================================================
% 2.2. Problema Geral do Emparelhamento
% ==================================================================================================================================
\subsection{Problema Geral do Emparelhamento}

O problema de \textbf{matching} (emparelhamento) em grafos é um problema fundamental na otimização combinatória

Um \textbf{matching} M em um grafo não-direcionado $G=(V,E)$ é um subconjunto de arestas $M \subseteq E$ tal que
nenhum par de arestas em $M$ compartilha um vértice comum \cite{kleinberg}. Em outras palavras, cada nó aparece em no máximo
uma aresta de $M$.

\begin{itemize}
    \item Um vértice é chamado \textbf{coberto} (\textit{matched}) se for incidente a uma aresta em $M$; caso contrário, 
    é \textbf{descoberto} (\textit{unmatched} ou \textit{exposed}) \cite{cormen}
    \item Um \textbf{matching de cardinalidade máxima} (Maximum Matching) é um matching com o maior número possível 
    de arestas \cite{cormen}. A cardinalidade máxima de um matching é denotada por $v(G)$ \cite{schrijver}
    \item Um \textbf{matching perfeito} é um matching que cobre todos os vértices do grafo \cite{kleinberg}
    \item  O \textbf{problema de matching ponderado} (Weighted Matching Problem) envolve encontrar um matching para o qual a 
    soma dos pesos das arestas é máxima. Em um grafo ponderado $G=(V,E,w)$, busca-se um $M\subseteq E$ que maximize $w(M)$ \cite{matching_gpus_sc24}
\end{itemize}

% ---------------------------------------------------------------------------------------------------------------------------------
% 2.2.1. Matching em grafos bipartidos
% ---------------------------------------------------------------------------------------------------------------------------------
\subsubsection{Matching em grafos bipartidos}

O problema de \textbf{Matching Bipartido} é o caso clássico de encontrar um matching de cardinalidade máxima em um grafo 
bipartido $G=(V,E)$, onde $V=X\cup Y$ \cite{kleinberg}

\begin{itemize}
    \item O matching em grafos bipartidos pode modelar situações de atribuição, como associar empregos ($X$) a máquinas ($Y$), 
    ou professores ($X$) a cursos ($Y$), onde uma aresta indica uma capacidade de atribuição \cite{kleinberg}
    \item O problema de matching ponderado em grafos bipartidos é equivalente ao \textbf{problema de atribuição \cite{lawler}}, 
    que historicamente motivou o desenvolvimento do \textbf{método Húngaro} \cite{schrijver}
\end{itemize}

% ---------------------------------------------------------------------------------------------------------------------------------
% 2.2.2. Formulação geral (emparelhamento e otimização)
% ---------------------------------------------------------------------------------------------------------------------------------
\subsubsection{Formulação geral (emparelhamento e otimização)}

Em um contexto mais amplo, o emparelhamento de grafos pode ser formalizado como um problema de otimização que 
busca maximizar a compatibilidade entre dois grafos $G$ e $G'$ \cite{learning_graph_matching}.

\begin{itemize}
    \item  O problema de graph matching é frequentemente abordado como um \textbf{problema de atribuição qua\-drática (QAP)}. 
    Essa formulação busca maximizar uma função objetivo que combina termos de compatibilidade unária (nó-nó, $c_{ii'}$) 
    e compatibilidade par a par (aresta-aresta, $d_{ii'jj'}$), sujeito a restrições de atribuição binária ($y_{ii'} \in {0,1}$). 
    O termo quadrático codifica a preservação das relações (arestas) entre os nós \cite{learning_graph_matching}
    \item Para grafos bipartidos, a determinação de um matching máximo pode ser resolvida de maneira eficiente e está intimamente 
    ligada a problemas de \textit{network flow} (fluxo em redes) \cite{kleinberg}
\end{itemize}
