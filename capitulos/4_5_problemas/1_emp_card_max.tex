% ------------------------------------------------------------------------------------------------
% 4.1. Emparelhamento de cardinalidade máxima
% ------------------------------------------------------------------------------------------------
\subsection{Emparelhamento de cardinalidade máxima}

\subsubsection{Descrição do problema}

Dado um grafo não-direcionado $G=(V,E)$, o problema de emparelhamento de cardinalidade máxima (MCM) busca encontrar um emparelhamento $M \subseteq E$ tal que o número de arestas em $M$ seja maximizado, ou seja, $|M|$ é o maior entre todos os emparelhamentos possíveis em $G$.

Um caso especial, mas importante, do MCM é o \textbf{Emparelhamento perfeito}, que é um emparelhamento onde todos os vértices do grafo são cobertos por exatamente uma aresta do emparelhamento. Para que um emparelhamento perfeito exista, o grafo deve ter um número par de vértices e o emparelhamento máximo deve ter cardinalidade igual a $|V|/2$ \cite{jungnickel}.

\subsubsection{Propriedades}

Antes de continuar para os algoritmos e soluções, é necessário entender algumas propriedades importantes

\paragraph{Emparelhamento máximo vs maximal}

Um emparelhamento máximo é aquele que contém o maior número possível de arestas, enquanto um emparelhamento maximal é aquele que não pode ser aumentado adicionando mais arestas, mas não necessariamente é o maior possível \cite{manber}.

\paragraph{Caminhos aumentantes}

Um caminho aumentante $P$ em um grafo $G$ é chamado de caminho aumentante se $P$ tem tamanho ímpar, começa e termina em vértices livres (não cobertos por nenhuma aresta do emparelhamento atual) e alterna entre arestas que pertencem a $M$ e arestas que não pertencem a $M$. A existência de um caminho aumentante indica que o emparelhamento atual não é máximo \cite{schrijver}

\paragraph{Teorema de Kőnig}

O teorema de Kőnig estabelece uma relação fundamental entre emparelhamentos e coberturas em grafos bipartidos. Ele afirma que, em qualquer grafo bipartido, o tamanho do maior emparelhamento é igual ao tamanho da menor cobertura de vértices \cite{jungnickel}.

A cobertura de vértices é um conjunto de vértices tal que cada aresta do grafo é incidente a pelo menos um vértice desse conjunto. O teorema de Kőnig é uma ferramenta poderosa para resolver problemas de emparelhamento, utilizado nos algoritmos de Hopcroft-Karp e no método Húngaro.

\subsubsection{Algoritmos exatos}
\label{sec:algos_exatos_emp_card_max}

Por ser em um ambiente mais restrito, o problema de emparelhamento de cardinalidade máxima tem diversas soluções em tempo polinomial. A seguir listadas algumas delas:

\paragraph{Algoritmo do caminho aumentante}

O algoritmo de caminho aumentante se baseia em um lema proposto por Claude Berge, que afirma que um grafo G é maximo se e somente se não existe nenhum caminho aumentante em G. Este algoritmo é uma implementação direta deste lema, onde se busca repetidamente por caminhos aumentantes e se aumenta o emparelhamento até que nenhum caminho aumentante possa ser encontrado \cite{lawler}.

Começamos com um emparelhamento vazio $M=\emptyset$. Escolhemos um vértice livre $u$ no lado esquerdo do grafo bipartido e tentamos encontrar um caminho aumentante $P$ que começa em $u$ e termina em um vértice livre no lado direito do grafo, respeitando a regra da alternância entre arestas em $M$ e arestas fora de $M$. Se um caminho aumentante for encontrado, atualizamos o emparelhamento $M$ invertendo as arestas ao longo do caminho $P$. Repetimos esse processo até que não seja possível encontrar mais caminhos aumentantes. O emparelhamento resultante será o emparelhamento de cardinalidade máxima \cite{halim}.

Em seguida o algoritmo em pseudo-código:

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetAlgoLined

    % Variáveis globais
    \textbf{Global:} $match$ (vetor de emparelhamento), $vis$ (vetor de visitados), $AdjList$\;
    \bigskip

    % Procedimento Augment (DFS)
    \Fn{Aug($l$)}{
        \If{$vis[l] = 1$}{
            \KwRet 0\;
        }
        $vis[l] \leftarrow 1$\;
        
        \For{each $r \in AdjList[l]$}{
            % A lógica do caminho aumentante
            \If{$match[r] = -1$ \KwOr Aug($match[r]$)}{
                $match[r] \leftarrow l$\;
                \KwRet 1 \textbf{[comment: found 1 matching]}\;
            }
        }
        \KwRet 0 \textbf{[comment: no matching]}\;
    }

    \bigskip

    % Procedimento Principal
    \Fn{MCBM\_Algorithm($n$)}{
        $MCBM \leftarrow 0$\;
        $match \leftarrow -1$ (initialize for all $V$)\;
        
        \For{$l \leftarrow 0$ \KwTo $n-1$}{
            $vis \leftarrow 0$ (reset before each recursion)\;
            $MCBM \leftarrow MCBM + \text{Aug}(l)$\;
        }
        
        \KwRet $MCBM$\;
    }
    
    \caption{Algoritmo de caminhos aumentantes (MCBM) \cite{halim}}
    \label{alg:mcbm_augmenting}
\end{algorithm}

Como o algoritmo repete a busca por caminhos aumentantes para cada vértice do lado esquerdo do grafo, o tempo de execução total do algoritmo é $O(VE)$, onde $V$ é o número de vértices e $E$ é o número de arestas no grafo bipartido \cite{halim}.

\paragraph{Redução ao problema de fluxo máximo}

O problema de emparelhamento de cardinalidade máxima em grafos bipartidos pode ser eficientemente resolvido através de uma redução ao problema de fluxo máximo em redes. A ideia central é construir uma rede de fluxo a partir do grafo bipartido original, onde cada aresta do grafo bipartido é convertida em uma aresta com capacidade unitária na rede de fluxo. \cite{lawler}

Primeiro, adicionamos um vértice fonte $s$ e um vértice sumidouro $t$ à rede. Conectamos o vértice fonte $s$ a todos os vértices do conjunto esquerdo do grafo bipartido com arestas de capacidade 1. Em seguida, conectamos todos os vértices do conjunto direito do grafo bipartido ao vértice sumidouro $t$, também com arestas de capacidade 1. As arestas entre os conjuntos esquerdo e direito do grafo bipartido são mantidas na rede de fluxo, cada uma com capacidade 1 \cite{halim}.

Com isso, temos agora um grafo de fluxo onde o objetivo é encontrar o fluxo máximo do vértice fonte $s$ para o vértice sumidouro $t$. O valor do fluxo máximo encontrado nesta rede corresponde ao tamanho do emparelhamento máximo no grafo bipartido original. \cite{lawler}. Para encontrar o fluxo máximo, podemos utilizar algoritmos clássicos como o de Edmonds-Karp.

O algoritmo de Edmonds-Karp é o padrão para resolver o problema de fluxo máximo, utilizando buscas em largura (BFS) para encontrar caminhos aumentantes na rede residual. A seguir, o pseudo-código do algoritmo:

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetAlgoLined

    % Variáveis globais explicadas no início (opcional, mas ajuda na clareza)
    \textbf{Global:} $res$ (matriz de capacidade residual), $mf, f, s, t$, $p$ (vetor de pais da BFS)\;
    \bigskip

    % Procedimento Recursivo AUGMENT
    \Fn{Augment($v, \text{minEdge}$)}{
        \eIf{$v = s$}{
            $f \leftarrow \text{minEdge}$\;
            \KwRet\;
        }{
            \If{$p[v] \neq -1$}{
                Augment($p[v], \min(\text{minEdge}, res_{p[v], v})$)\;
                $res_{p[v], v} \leftarrow res_{p[v], v} - f$\;
                $res_{v, p[v]} \leftarrow res_{v, p[v]} + f$\;
            }
        }
    }

    \bigskip

    % Procedimento Principal (Main)
    \Fn{EdmondsKarp($s, t$)}{
        $mf \leftarrow 0$\;
        
        \While{\KwTrue}{
            $f \leftarrow 0$\;
            
            % Setup da BFS
            $dist \leftarrow \infty; \quad dist[s] \leftarrow 0$\;
            $Q \leftarrow \{s\}; \quad p \leftarrow \text{nil}$ (init vector with -1)\;

            % BFS Loop
            \While{$Q \neq \emptyset$}{
                $u \leftarrow Q.\text{front}()$; $Q.\text{pop}()$\;
                
                \If{$u = t$}{
                    \KwBreak (stop BFS)\;
                }

                \For{each $v \in V$}{
                    \If{$res_{u, v} > 0$ \KwAnd $dist[v] = \infty$}{
                        $dist[v] \leftarrow dist[u] + 1$\;
                        $Q.\text{push}(v)$\;
                        $p[v] \leftarrow u$\;
                    }
                }
            }

            Augment($t, \infty$); \textbf{[comment: find min edge weight $f$ in path]}\;
            
            \If{$f = 0$}{
                \KwBreak (terminate)\;
            }
            $mf \leftarrow mf + f$\;
        }
        
        \KwRet $mf$\;
    }
    
    \caption{Algoritmo de Edmonds-Karp \cite{halim}}
    \label{alg:edmonds_karp}
\end{algorithm}

Outra opção para resolver o problema de fluxo máximo é o algoritmo de Dinic, que é mais eficiente em muitos casos práticos, especialmente em grafos densos. O algoritmo de Dinic utiliza uma combinação de buscas em largura (BFS) para construir níveis na rede residual e buscas em profundidade (DFS) para encontrar caminhos aumentantes dentro desses níveis. O tempo de execução do algoritmo de Dinic é $O(E \sqrt{V})$ para grafos gerais, tornando-o uma escolha preferida para muitos problemas de fluxo máximo \cite{halim}.

Este trabalho não tem uma implementação do algoritmo de Dinic. Ao invés disso, será apresentado o algoritmo de Hopcroft-Karp, que é uma variação especializada do algoritmo de Dinic para o problema de emparelhamento em grafos bipartidos, oferecendo uma solução mais eficiente para este caso específico.

\paragraph{Algoritmo de Hopcroft-Karp}

O algoritmo de Hopcroft-Karp é um algoritmo eficiente para encontrar o emparelhamento máximo em grafos bipartidos. Ele melhora o desempenho do algoritmo de caminhos aumentantes ao encontrar múltiplos caminhos aumentantes em cada iteração, em vez de apenas um. O tempo de execução do algoritmo de Hopcroft-Karp é $O(E \sqrt{V})$, tornando-o significativamente mais rápido do que o algoritmo de caminhos aumentantes simples, especialmente em grafos grandes \cite{halim}.

O algoritmo consiste em duas fases principais: a fase de construção de níveis e a fase de busca de caminhos aumentantes. Na fase de construção de níveis, uma busca em largura (BFS) é realizada a partir dos vértices livres no lado esquerdo do grafo bipartido para construir uma camada de níveis que ajuda a identificar os caminhos aumentantes mais curtos. Na fase de busca de caminhos aumentantes, uma busca em profundidade (DFS) é realizada para encontrar todos os caminhos aumentantes possíveis dentro da camada de níveis construída na fase anterior. Esses caminhos são então usados para aumentar o emparelhamento \cite{halim}.

% TODO: melhorar essa explicação

A seguir, o pseudo-código do algoritmo de Hopcroft-Karp:

\begin{algorithm}[H]
    \DontPrintSemicolon
    \SetAlgoLined

    \caption{Algoritmo de Hopcroft-Karp \cite{burkard}}
    \label{alg:hopcroft_karp}

    % MAIN ALGORITHM
    \KwLet $G = (U, V; E)$ be a bipartite graph with initial (possibly empty) matching $M$;\;
    \KwLet $U_0$ contain all unmatched vertices of $U$;\;
    \KwLet $V_0$ contain all unmatched vertices of $V$;\;
    
    \While{$U_0 \neq \emptyset$}{
        Construct\_layered\_graph;\;
        Find\_set\_$\Delta M$;\;
        $M := M \ominus \Delta M$;\;
        update sets $U_0, V_0$ of unmatched vertices\;
    }

    \bigskip

    % PROCEDURE 1: CONSTRUCT LAYERED GRAPH
    \Fn{Construct\_layered\_graph}{
        $L_0 := U_0, k^* := k := 0$;\;
        \While{$L_k \neq \emptyset$}{
            \For{each $i \in L_k$}{
                $N(i) := \{ j : [i, j] \in E \setminus M, j \notin L_1 \cup L_3 \cup \dots \cup L_{k-1} \}$;
            }
            $L_{k+1} := \bigcup_{i \in L_k} N(i)$;\;
            
            \If{$L_{k+1} = \emptyset$}{
                \KwStop \AlgComment{$M$ is a maximum matching}
            }
            
            \eIf{$L_{k+1} \cap V_0 \neq \emptyset$}{
                $k^* := k + 1$;\;
                $L_{k+2} := \emptyset$\;
            }{
                $L_{k+2} := \{ \overline{i} : [\overline{i}, j] \in M, j \in L_{k+1} \}$;
            }
            $k := k + 2$\;
        }
    }

    \bigskip

    % PROCEDURE 2: FIND SET DELTA M
    \Fn{Find\_set\_$\Delta M$}{
        \AlgComment{find a maximal set $\Delta M$ of disjoint augmenting paths}\;
        delete all vertices in $L_{k^*} \setminus V_0$;\;
        mark all remaining vertices as unscanned;\;
        $k := 1$; \AlgComment{path counter}\;
        
        \While{$L_0 \neq \emptyset$}{
            choose $x_0 := i \in L_0$ and delete it in $L_0$;\;
            $\ell := 0$;\;
            
            \While{$\ell \ge 0$}{
                \While{$x_\ell$ has an unscanned neighbor in $L_{\ell+1}$}{
                    choose unscanned neighbor $x_{\ell+1}$;\;
                    mark $x_{\ell+1}$ as scanned;\;
                    $\ell := \ell + 1$;\;
                    
                    \If{$\ell = k^*$}{
                        $P_k := (x_0, x_1, \dots, x_{k^*})$;\;
                        $k := k + 1$\;
                    }
                }
                \eIf{$\ell < k^*$}{
                    $\ell := \ell - 1$\;
                }{
                    $\ell := -1$\;
                }
            }
        }
        \KwRet $\Delta M := (P_1, P_2, \dots, P_{k-1})$\;
    }

\end{algorithm}

